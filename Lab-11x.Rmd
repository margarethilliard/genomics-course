---
title: "Lab 11A: Microbiome Analysis using phyloseq"
author: "Margaret Hilliard"
date: "11/11/2020"
output: html_document
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# phyloseq

## Ordination Plot 

### Load Packages, Prepare Data

Load the necessary packages and data.
```{r}
library("phyloseq"); packageVersion("phyloseq")
```
```{r}
data(GlobalPatterns)
library("ggplot2"); packageVersion("ggplot2")
```
```{r}
library("plyr"); packageVersion("plyr")
```
ggplot2 package theme set. See the ggplot2 online documentation for further help.
```{r}
theme_set(theme_bw())
```
We want to filter low-occurrence, poorly-represented OTUs from this data, because they are essentially noise variables for the purposes of this tutorial. In practice, you should probably perform and clearly-document well-justified preprocessing steps, which are supported in the phyloseq package with examples and details on a dedicated preprocessing tutorial.

In this case preprocessing is especially useful for showing graphically the high-level patterns in the data, as well as creating examples that compute in a short amount of time. Your reasoning and decisions in preprocessing are extremely important, and up to you. I am using several different methods of preprocessing here, for illustration and because the extent of data reduction is useful for my purposes. However, I make no assertion that these are the “optimum” approach(es) for your data and research goals, but rather, I highly recommend that you think hard about any preprocessing that you do, document it completely, and only commit to including it in your final analysis pipeline if you can defend the choices and have checked that they are robust.

To quickly demonstrate and compare the results of different ordination methods, I will first further filter/preprocess the OTUs in GP1. I want to include some phylogenetic tree-based ordinations, which can be slow to calculate. Since the goal of this exercise is to demonstrate the plot_ordination capability, and not necessarily reveal any new knowledge about the Global Patterns dataset, the emphasis on this preprocessing will be on limiting the number of OTUs, not protecting intrinsic patterns in the data.

Remove OTUs that do not show appear more than 5 times in more than half the samples
```{r}
GP = GlobalPatterns
wh0 = genefilter_sample(GP, filterfun_sample(function(x) x > 5), A=0.5*nsamples(GP))
GP1 = prune_taxa(wh0, GP)
```
Transform to even sampling depth.
```{r}
GP1 = transform_sample_counts(GP1, function(x) 1E6 * x/sum(x))
```
Keep only the most abundant five phyla.
```{r}
phylum.sum = tapply(taxa_sums(GP1), tax_table(GP1)[, "Phylum"], sum, na.rm=TRUE)
top5phyla = names(sort(phylum.sum, TRUE))[1:5]
GP1 = prune_taxa((tax_table(GP1)[, "Phylum"] %in% top5phyla), GP1)
```
That still leaves 204 OTUs in the dataset, GP1.

We will want to investigate a major prior among the samples, which is that some are human-associated microbiomes, and some are not. Define a human-associated versus non-human categorical variable:
```{r}
human = get_variable(GP1, "SampleType") %in% c("Feces", "Mock", "Skin", "Tongue")
sample_data(GP1)$human <- factor(human)
```

### Four main ordination plots

The plot_ordination function supports four basic representations of an ordination. For some methods, like PCoA/MDS on a distance matrix of samples, any methods displaying OTUs is not supported because OTUs are not part of the ordination in that case.

#### (1) Just OTUs

Let’s start by plotting just the OTUs, and shading the points by Phylum. Note that even in our “trimmed” dataset there are ntaxa(GP1)= 204 OTUs.
```{r}
GP.ord <- ordinate(GP1, "NMDS", "bray")
p1 = plot_ordination(GP1, GP.ord, type="taxa", color="Phylum", title="taxa")
print(p1)
```
This is a complicated looking plot, but that’s not necessarily good. There is actually a lot of overplotting/occlusion, which means that the high number of points is getting in the way of our visual understanding of the data. There are several ways to deal with this in ggplot2, for example, facetting:
```{r}
p1 + facet_wrap(~Phylum, 3)
```

#### (2) Just samples 

Next, let’s plot only the samples, and shade the points by “SampleType” while also modifying the shape according to whether they are human-associated. There are a few additional ggplot2 layers added to make the plot even nicer…
```{r}
p2 = plot_ordination(GP1, GP.ord, type="samples", color="SampleType", shape="human") 
p2 + geom_polygon(aes(fill=SampleType)) + geom_point(size=5) + ggtitle("samples")
```

#### (3) biplot graphic

The plot_ordination function can also automatically create two different graphic layouts in which both the samples and OTUs are plotted together in one “biplot”. Note that this requires methods that are not intrinsically samples-only ordinations. For example, this doesn’t work with UniFrac/PCoA.

```{r}
p3 = plot_ordination(GP1, GP.ord, type="biplot", color="SampleType", shape="Phylum", title="biplot")
# Some stuff to modify the automatic shape scale
GP1.shape.names = get_taxa_unique(GP1, "Phylum")
GP1.shape <- 15:(15 + length(GP1.shape.names) - 1)
names(GP1.shape) <- GP1.shape.names
GP1.shape["samples"] <- 16
p3 + scale_shape_manual(values=GP1.shape)
```

#### (4) split graphic

Hmmm. In the previous graphic the occlusion problem is pretty strong. In this case the type="split" option can be helpful, in which the samples/OTUs are separated on two side-by-side panels…
```{r}
p4 = plot_ordination(GP1, GP.ord, type="split", color="Phylum", shape="human", label="SampleType", title="split") 
p4
```

Probably much better if sample colors were black. The following function reproduces ggplot2’s default color scale. Solution borrowed from a StackOverflow page on ggplot2.
```{r}
gg_color_hue <- function(n){
    hues = seq(15, 375, length=n+1)
    hcl(h=hues, l=65, c=100)[1:n]
}
color.names <- levels(p4$data$Phylum)
p4cols <- gg_color_hue(length(color.names))
names(p4cols) <- color.names
p4cols["samples"] <- "black"
p4 + scale_color_manual(values=p4cols)
```

### Supported Ordination Methods

In this section I loop through different method parameter options to the plot_ordination function, store the plot results in a list, and then plot these results in a combined graphic using ggplot2.
```{r}
dist = "bray"
ord_meths = c("DCA", "CCA", "RDA", "DPCoA", "NMDS", "MDS", "PCoA")
plist = llply(as.list(ord_meths), function(i, physeq, dist){
        ordi = ordinate(physeq, method=i, distance=dist)
        plot_ordination(physeq, ordi, "samples", color="SampleType")
}, GP1, dist)
```
```{r}
names(plist) <- ord_meths
```
The previous code chunk performed each ordination method, created the corresponding graphic based on the first two axes of each ordination result, and then stored each ggplot2 plot object in a different named element of the list named plist. The following chunk will extract the data from each of those individual plots, and put it back together in one big data.frame suitable for including all plots in one graphic.
```{r}
pdataframe = ldply(plist, function(x){
    df = x$data[, 1:2]
    colnames(df) = c("Axis_1", "Axis_2")
    return(cbind(df, x$data))
})
names(pdataframe)[1] = "method"
```

Now that all the ordination results are combined in one data.frame, called pdataframe, we can use this to make a standard faceted ggplot scatterplot.
```{r}
p = ggplot(pdataframe, aes(Axis_1, Axis_2, color=SampleType, shape=human, fill=SampleType))
p = p + geom_point(size=4) + geom_polygon()
p = p + facet_wrap(~method, scales="free")
p = p + scale_fill_brewer(type="qual", palette="Set1")
p = p + scale_colour_brewer(type="qual", palette="Set1")
p
```
If you want to replot a larger version of an individual plot, you can do by printing from the original plist from which pdataframe was made. Each element of plist is already a ggplot2 graphic. For example, we can replot the detrended correspondence analysis (DCA) by printing the second element of the list.
```{r}
plist[[2]] 
```
Now add some extra layers to make it look nicer.
```{r}
p = plist[[2]] + scale_colour_brewer(type="qual", palette="Set1")
p = p + scale_fill_brewer(type="qual", palette="Set1")
p = p + geom_point(size=5) + geom_polygon(aes(fill=SampleType))
p
```

### MDS (“PCoA”) on Unifrac Distances

Use the ordinate function to simultaneously perform weightd UniFrac and then perform a Principal Coordinate Analysis on that distance matrix (first line). Next pass that data and the ordination results to plot_ordination to create the ggplot2 output graphic with default ggplot2 settings.
```{r}
ordu = ordinate(GP1, "PCoA", "unifrac", weighted=TRUE)
plot_ordination(GP1, ordu, color="SampleType", shape="human")
```
Now make the graphic look nicer with a few additional ggplot2 layers.
```{r}
p = plot_ordination(GP1, ordu, color="SampleType", shape="human")
p = p + geom_point(size=7, alpha=0.75)
p = p + scale_colour_brewer(type="qual", palette="Set1")
p + ggtitle("MDS/PCoA on weighted-UniFrac distance, GlobalPatterns")
```

## Alpha diversity graphics

Examples using the plot_richness function.

Although the function name includes the word richness, which usually refers to the total number of species/OTUs/taxa in a sample or environment – either observed or estimated – this is actually a wrapper for all descriptions of alpha diversity. The name of this function may be changed in future versions to reflect this and avoid confusion.

### Load packages, set parameters

As usual, we must start by loading the phyloseq package, and then the dataset, in this case "GlobalPatterns".
```{r}
library("phyloseq"); packageVersion("phyloseq")
```
```{r}
data("GlobalPatterns")
```
Some ggplot2 theming. First load the ggplot2 package.
```{r}
library("ggplot2"); packageVersion("ggplot2")
```
```{r}
theme_set(theme_bw())
pal = "Set1"
scale_colour_discrete <-  function(palname=pal, ...){
  scale_colour_brewer(palette=palname, ...)
}
scale_fill_discrete <-  function(palname=pal, ...){
  scale_fill_brewer(palette=palname, ...)
}
```

### Prepare data

Since we are interested in alpha diversity, it is probably not a bad idea to prune OTUs that are not present in any of the samples (for some reason there are a few in "GlobalPatterns") – BUT DON’T TRIM MORE THAN THAT! I know it is tempting to trim noise right away, but many richness estimates are modeled on singletons and doubletons in the abundance data. You need to leave them in the dataset if you want a meaningful estimate.
```{r}
GP <- prune_species(speciesSums(GlobalPatterns) > 0, GlobalPatterns)
```

### Plot Examples

Here is the default graphic produced by the plot_richness function on the GP example dataset:
```{r}
plot_richness(GP)
```
Note that in this case, the Fisher calculation results in a warning (but still plots). We can avoid this by specifying a measures argument to plot_richness, which will include just the alpha-diversity measures that we want.
```{r}
plot_richness(GP, measures=c("Chao1", "Shannon"))
```
We can specify a sample variable on which to group/organize samples along the horizontal (x) axis. An experimentally meaningful categorical variable is usually a good choice – in this case, the "SampleType" variable works much better than attempting to interpret the sample names directly (as in the previous plot):
```{r}
plot_richness(GP, x='SampleType', measures =c("Chao1", "Shannon"))
```
Now suppose we wanted to use an external variable in the plot that isn’t in the GP dataset already – for example, a logical that indicated whether or not the samples are human-associated. First, define this new variable, human, as a factor (other vectors could also work; or other data you might have describing the samples).
```{r}
sampleData(GP)$human <- getVariable(GP, "SampleType") %in% c("Feces", "Mock", "Skin", "Tongue")
```
Now tell plot_richness to map the new human variable on the horizontal axis, and shade the points in different color groups, according to which "SampleType" they belong.
```{r}
plot_richness(GP, x="human", color="SampleType", measures=c("Chao1", "Shannon"))
```
We can merge samples that are from the environment (SampleType), and make the points bigger with a ggplot2 layer. First, merge the samples.
```{r}
GPst = merge_samples(GP, "SampleType")
# repair variables that were damaged during merge (coerced to numeric)
sample_data(GPst)$SampleType <- factor(sample_names(GPst))
sample_data(GPst)$human <- as.logical(sample_data(GPst)$human)
```
Now we can plot this environment-merged version of the data. First store the default ggplot graphic as p, then add an additional geom_point layer with a large size and slight transparency.
```{r}
p = plot_richness(GPst, x="human", color="SampleType", measures=c("Chao1", "Shannon"))
p + geom_point(size=5, alpha=0.7)
```

### More details about ggplot2

For those interested in why this works so concisely (p + geom_point(size=4, alpha=0.7)), it is because the rest of the aesthetic mapping and data are contained in the ggplot object, p, and so is inherited in the call to the ggplot2 geometric object layer function, geom_point, by default since we didn’t specify alternative aes or data arguments. Although we could have if we wanted to. This perhaps sounds more confusing than it is, and I find it easier to understand by inspecting the examples I’ve shown here.

You’ll also notice that the original smaller points are still on the plot. This is because they were the first layer, and our larger points are semi-transparent. I find this kind of distracting, and doesn’t add any information or clarity. The good news is that layers can be removed from a ggplot object with standard list notation (using the dollar sign $).

First, check which lists are present in p.
```{r}
p$layers
```
We can see that the first layer is the one specifying the original points, which are small. We can use negative indexing to “pop” it out, then add a new geom_point layer with larger point size (the following two lines).
```{r}
p$layers <- p$layers[-1]
p + geom_point(size=5, alpha=0.7)
```

## Heatmap Plots

The following demonstrates some uses of the plot_heatmap function in the phyloseq package for R and Bioconductor.

### Introduction 

#### An ecologically-organized heatmap

In a 2010 article in BMC Genomics, Rajaram and Oono describe an approach to creating a heatmap using ordination methods (namely, NMDS and PCA) to organize the rows and columns instead of (hierarchical) cluster analysis. In many cases the ordination-based ordering does a much better job than h-clustering at providing an order of elements that is easily interpretable. The authors provided an immediately useful example of their approach as the NeatMap package for R. The NeatMap package can be used directly on the abundance table ("otu_table"-class) of phylogenetic-sequencing data, but the NMDS or PCA ordination options that it supports are not based on ecological distances. To fill this void, and because phyloseq already provides support for a large number of ecological distances and ordination methods, phyloseq now includes the plot_heatmap() function: an ecology-oriented variant of the NeatMap approach to organizing a heatmap and build it using ggplot2 graphics tools. The distance and method arguments are the same as for the plot_ordination function, and support large number of distances and ordination methods, respectively, with a strong leaning toward ecology. This function also provides the options to re-label the OTU and sample axis-ticks with a taxonomic name and/or sample variable, respectively, in the hope that this might hasten your interpretation of the patterns (See the documentation for the sample.label and taxa.label arguments, and the examples below). Note that this function makes no attempt to overlay dendrograms from hierarchical clustering next to the axes, as hierarchical clustering is not used to organize these plots. Also note that each re-ordered axis repeats at the edge, and so apparent clusters at the far right/left or top/bottom of the heat-map may actually be the same. For now, the placement of this edge can be considered arbitrary, so beware of this artifact of the graphic and visually check if there are two “mergeable” clusters at the edges of a particular axis. If you benefit from this phyloseq-specific implementation of the NeatMap approach, please cite the NeatMap article, as well as phyloseq.

#### Heatmap colors don’t have to be so hot

Traditionally heatmaps have been used to emphasize data that is above or below a threshold as “hot” or “cold” colors, respectively. In the case of OTU-abundance data, however, it seems the most common need is to see the relative patterns of high-abundance OTUs against a background of taxa that are mostly low-abundance or absent in a sparse matrix. Furthermore, there is usually not an obvious or intrinsically meaningful abundance value to use as a suitable threshold for the traditional “cold/hot” display. For these reasons, the default color scheme in plot_heatmap maps a very dark blue color to the lowest abundance values, up to a very light blue for the highest abundance values. This default continuous color palette is a coherent, blue-oriented color scheme in which the eye should be drawn to the lighter shades. The dark blue for the lowest abundance values is not very much lighter than black, and true black is used to represent missing or zero abundance values.

If, for whatever reason, you need to change this default color scheme, it is possible through the low, high, and na.value arguments. Several examples are provided below. The character-string values supplied to these arguments need to be the names of R colors. There are over 600 English color names that are understood by R (try colors() at the R terminal), as well as other finely-resolved color gradient nomenclatures. The examples below use a 6-digit hexadecimal color representation, and a nice [table summary of these colors is available at the R Cookbook](http://wiki.stdout.org/rcookbook/Graphs/Colors%20(ggplot2\)/).

For further details, not that the high, low, and na.value parameters are passed along to ggplot2’s scale_gradient function, which does an excellent job selecting suitable colors of your gradient, provided that you select colors that make sense to have at two ends of a gradient.

I also got some useful ideas and suggestions at the following WordPress page regarding the construction of heatmaps using ggplot2’s geom_tile.

#### Color scaling

In addition to the color palette that defines the poles, color in the heatmap is also characterized by the numerical transformation from observed value to color – called color scaling.

By default, the plot_heatmap color scale is a log transformation with base 4, using log_trans(4) from the scales package. This is an arbitrary choice that you might need to adjust based on your needs and data. If specifying an alternative transformation object to the trans argument, you probably need to load the scales package first. Since scales is a required package for phyloseq, you should already have it installed if you are at this point. Any transformation object that is valid for the scales package should work here, but the relative contrast and the way it represents your data could change dramatically based on this choice, so make this selection carefully; or better yet, try several different transformations if you think data is being “left in the background” or too much information is being “pushed to the foreground”, for example.

#### Examples 

##### Load Packages, Data

```{r}
library("phyloseq"); packageVersion("phyloseq")
```
```{r}
library("ggplot2"); packageVersion("ggplot2")
```
ggplot2 package theme set. See the ggplot2 online documentation for further help.
```{r}
theme_set(theme_bw())
```

##### Plot a 300-taxa dataset

The following two lines subset the dataset to just the top 300 most abundant Bacteria taxa across all samples (in this case, with no prior preprocessing. Not recommended, but quick).
```{r}
data("GlobalPatterns")
gpt <- subset_taxa(GlobalPatterns, Kingdom=="Bacteria")
gpt <- prune_taxa(names(sort(taxa_sums(gpt),TRUE)[1:300]), gpt)
plot_heatmap(gpt, sample.label="SampleType")
```

##### Subset a smaller dataset based on an Archaeal phylum

Subset the dataset to something manageable that can be reasonably represented in one plot. In the following examples, the Crenarchaeota phylum.
```{r}
gpac <- subset_taxa(GlobalPatterns, Phylum=="Crenarchaeota")
```

##### Default plot_heatmap settings

Now let’s see how our plot_heatmap function works with all default settings.
```{r}
plot_heatmap(gpac)
```

##### Re-label by a sample variable and taxonomic family

Here is an example re-labelling based on the “SampleType” sample variable and the taxonomic rank of “Family”.
```{r}
(p <- plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family"))
```

##### Re-label axis titles

What if you wanted to change the axis labels, but not the labels on individual features?
```{r}
p$scales$scales[[1]]$name <- "My X-Axis"
p$scales$scales[[2]]$name <- "My Y-Axis"
print(p)
```

##### Now repeat the plot, but change the color scheme.

Changing the color scheme might be worthwhile, depending on the graphics device or paper on which you want to display the heatmap.
```{r}
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family", low="#000033", high="#CCFF66")
```

Here is a dark-blue to red scheme.
```{r}
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family", low="#000033", high="#FF3300")
```

A very dark-blue to very light-blue scheme
```{r}
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family", low="#000033", high="#66CCFF")
```

Here is a “dark on light” color scheme. Note that we change the background value (the value of the NA and 0 elements)
```{r}
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family", low="#66CCFF", high="#000033", na.value="white")
```
This is a similar color scheme as the previous, but the “near zero” color is closer to a cream color, and the colors themselves are closer to blue-grey. This is better overall contrast than a lot of schemes, but may not be as exciting.
```{r}
plot_heatmap(gpac, "NMDS", "bray", "SampleType", "Family", low="#FFFFCC", high="#000033", na.value="white")
```

#### Now try different ordination methods, distances

Now try the default color scheme, but using different ecological distances/ordinations. For example, NMDS ordination on the jaccard distance.
```{r}
plot_heatmap(gpac, "NMDS", "jaccard")
```

Detrended correspondence analysis.
```{r}
plot_heatmap(gpac, "DCA", "none", "SampleType", "Family")
```

Unconstrained redundancy analysis (Principle Components Analysis, PCA)
```{r}
plot_heatmap(gpac, "RDA", "none", "SampleType", "Family")
```

PCoA/MDS ordination on the (default) bray-curtis distance.
```{r}
plot_heatmap(gpac, "PCoA", "bray", "SampleType", "Family")
```

MDS/PCoA ordination on the Unweighted-UniFrac distance.
```{r}
plot_heatmap(gpac, "PCoA", "unifrac", "SampleType", "Family")
```

Now try wei
ghted-UniFrac distance and MDS/PCoA ordination.
```{r}
plot_heatmap(gpac, "MDS", "unifrac", "SampleType", "Family", weighted=TRUE)
```
Here is how you might create a heatmap using base-R graphics and the more common (but problematic) hierarchical clustering organization, in case you want to compare with plot_heatmap, for example.
```{r}
heatmap(otu_table(gpac))
```

## Plot Microbiome Network
 
### Load Package and Example Data

```{r}
library(phyloseq); packageVersion("phyloseq")
```
```{r}
packageVersion("ggplot2")
```
```{r}
data(enterotype)
```
There is a random aspect to some of the network layout methods. For complete reproducibility of the images produced later in this tutorial, it is possible to set the random number generator seed explicitly:
```{r}
set.seed(711L)
```
Because we want to use the enterotype designations as a plot feature in these plots, we need to remove the 9 samples for which no enterotype designation was assigned (this will save us the hassle of some pesky warning messages, but everything still works; the offending samples are anyway omitted).
```{r}
enterotype = subset_samples(enterotype, !is.na(Enterotype))
```

### The plot_net function

The newer plot_net function does not require a separate make_network function call, or a separate igraph object. For examples running the older plot_network function, which may provide some added flexibility with igraph objects, see the plot_network section later.

Try plot_net with the default settings.
```{r}
plot_net(enterotype, maxdist = 0.4, point_label = "Sample_ID")
```
The previous graphic displayed some interesting structure, with one or two major subgraphs comprising a majority of samples. Furthermore, there seemed to be a correlation in the sample naming scheme and position within the network. Instead of trying to read all of the sample names to understand the pattern, let’s map some of the sample variables onto this graphic as color and shape:
```{r}
plot_net(enterotype, maxdist = 0.3, color = "SeqTech", shape="Enterotype")
```
In the previous examples, the choice of maximum-distance and distance method were informed, but arbitrary. Try what happens when maxdist value is decreased (hint: this will usually decrease the number of edges in the network).

### The plot_network function

Create an igraph-based network based on the default distance method, “Jaccard”, and a maximum distance between connected nodes of 0.3.
```{r}
ig <- make_network(enterotype, max.dist=0.3)
```
Now plot this network representation with the default settings.
```{r}
plot_network(ig, enterotype)
```
The previous raphic displayed some interesting structure, with a major subgraph comprising a majority of samples. Furthermore, there seemed to be a correlation in the sample naming scheme and position within the network. Instead of trying to read all of the sample names to understand the pattern, let’s map some of the sample variables onto this graphic as color and shape:
```{r}
plot_network(ig, enterotype, color="SeqTech", shape="Enterotype", line_weight=0.4, label=NULL)
```
In the previous examples, the choice of maximum-distance and distance method were informed, but arbitrary. Let’s see what happens when the maximum distance is lowered, decreasing the number of edges in the network
```{r}
ig <- make_network(enterotype, max.dist=0.2)
plot_network(ig, enterotype, color="SeqTech", shape="Enterotype", line_weight=0.4, label=NULL)
```
Let’s repeat the previous exercise, but replace the Jaccard (default) distance method with Bray-Curtis
```{r}
ig <- make_network(enterotype, dist.fun="bray", max.dist=0.3)
plot_network(ig, enterotype, color="SeqTech", shape="Enterotype", line_weight=0.4, label=NULL)
```

## Powerful tree graphics with ggplot2

This page demos already-constructed examples of phylogenetic trees created via the plot_tree function in the phyloseq package, which in-turn uses the powerful graphics package called ggplot2.

### Load the package and datasets

```{r}
library("phyloseq")
data("esophagus")
data("GlobalPatterns")
```
For completeness, here is the version number of phyloseq used to build this instance of the tutorial – and also how you can check your own current version from the command line.
```{r}
packageVersion("phyloseq")
```
We will also use ggplot2 commands in at least one section, so we will load ggplot2 now as well.
```{r}
library("ggplot2"); packageVersion("ggplot2")
```

### Example 

We want to plot trees, sometimes even bootstrap values, but notice that the node labels in the GlobalPatterns dataset are actually a bit strange. They look like they might be bootstrap values, but they sometimes have two decimals.
```{r}
head(phy_tree(GlobalPatterns)$node.label, 10)
```
Could systematically remove the second decimal, but why not just take the first 4 characters instead?
```{r}
phy_tree(GlobalPatterns)$node.label = substr(phy_tree(GlobalPatterns)$node.label, 1, 4)
```
Great, now that we’re more happy with the node labels at least looking like bootstrap values, we can move on to using these along with other information about data mapped onto the tree graphic.

The GlobalPatterns dataset has many OTUs, more than we would want to try to fit on a tree graphic
```{r}
ntaxa(GlobalPatterns)
```
So, let’s arbitrarily prune to just the first 50 OTUs in GlobalPatterns, and store this as physeq, which also happens to be the name for most main data parameters of function in the phyloseq package.
```{r}
physeq = prune_taxa(taxa_names(GlobalPatterns)[1:50], GlobalPatterns)
```
Now let’s look at what happens with the default plot_tree settings.
```{r}
plot_tree(physeq)
```
By default, dots are annotated next to tips (OTUs) in the tree, one for each sample in which that OTU was observed. Some have more dots than others. Also by default, the node labels that were stored in the tree were added next to each node without any processing (although we had trimmed their length to 4 characters in the previous step).

What if we want to just see the tree with no sample points next to the tips?
```{r}
plot_tree(physeq, "treeonly")
```
And what about without the node labels either? 
```{r}
plot_tree(physeq, "treeonly", nodeplotblank)
```
We can adjust the way branches are rotated to make it look nicer using the ladderize parameter. 
```{r}
plot_tree(physeq, "treeonly", nodeplotblank, ladderize="left")
```
```{r}
plot_tree(physeq, "treeonly", nodeplotblank, ladderize=TRUE)
```
And what if we want to add the OTU labels next to each tip?
```{r}
plot_tree(physeq, nodelabf=nodeplotblank, label.tips="taxa_names", ladderize="left")
```
Any method parameter argument other than "sampledodge" (the default) will not add dodged sample points next to the tips.
```{r}
plot_tree(physeq, "anythingelse")
```

#### Mapping Variables in Data

In the default argument to method, "sampledodge", a point is added next to each OTU tip in the tree for every sample in which that OTU was observed. We can then map certain aesthetic features of these points to variables in our data.

#### Color 

Color is one of the most useful aesthetics in tree graphics when they are complicated. Color can be mapped to either taxonomic ranks or sample covariates. For instance, we can map color to the type of sample collected (environmental location).
```{r}
plot_tree(physeq, nodelabf=nodeplotboot(), ladderize="left", color="SampleType")
```
And we can alternatively map color to taxonomic class.
```{r}
plot_tree(physeq, nodelabf=nodeplotboot(), ladderize="left", color="Class")
```

#### Shape 

You can also map a variable to point shape if it has 6 or fewer categories, and this can be done even when color is also mapped. Here we map shape to taxonomic class so that we can still indicate it in the graphic while also mapping SampleType to point color.
```{r}
plot_tree(physeq, nodelabf=nodeplotboot(), ladderize="left", color="SampleType", shape="Class")
```

#### Node Labels 

One of the most common reasons to label nodes is to add confidence measures, often a bootstrap value, to the nodes of the tree. The following graphics show different ways of doing this (labels are added by default if present in your tree).
```{r}
# The default
plot_tree(physeq, color="SampleType", ladderize="left")
```
```{r}
# Special bootstrap label
plot_tree(physeq, nodelabf=nodeplotboot(), color="SampleType", ladderize="left")
```
```{r}
# Special bootstrap label with alternative thresholds
plot_tree(physeq, nodelabf=nodeplotboot(80,0,3), color="SampleType", ladderize="left")
```

#### Tip Labels 


    label.tips - The label.tips parameter controls labeling of tree tips (AKA leaves). Default is NULL, indicating that no tip labels will be printed. If "taxa_names" is a special argument resulting in the OTU name (try taxa_names function) being labelled next to the leaves or next to the set of points that label the leaves. Alternatively, if your data object contains a tax_table, then one of the rank names (from rank_names(physeq)) can be provided, and the classification of each OTU at that rank will be labeled instead.
    text.size - A positive numeric argument indicating the ggplot2 size parameter for the taxa labels. Default is NULL. If left as NULL, this function will automatically calculate a (hopefully) optimal text size given the size constraints posed by the tree itself (for a vertical tree). This argument is included mainly in case the automatically-calculated size is wrong and you want to change it. Note that this parameter is only meaningful if label.tips is not NULL

```{r}
plot_tree(physeq, nodelabf=nodeplotboot(80,0,3), color="SampleType", label.tips="taxa_names", ladderize="left")
```

#### Radial Tree 

Making a radial tree is easy with ggplot2, simply recognizing that our vertically-oriented tree is a cartesian mapping of the data to a graphic – and that a radial tree is the same mapping, but with polar coordinates instead.
```{r}
data(esophagus)
plot_tree(esophagus, color="Sample", ladderize="left") + coord_polar(theta="y")
```
The GlobalPatterns dataset has additional data we can map, so we will re-do some preliminary data loading/trimming to make this radial-tree example self contained, and then show the same plot as above.
```{r}
plot_tree(physeq, nodelabf=nodeplotboot(60,60,3), color="SampleType", shape="Class", ladderize="left") + coord_polar(theta="y")
```

#### The esophagus dataset 

A simple dataset containing tree and OTU-table components.

The esophagus is a small and relatively simple dataset by moderns standards. It only contains 3 samples, no sample-data, and a modest quantity of total sequencing per sample that is a relic of an earlier time when resources for this sort of investigation were sparse and sequencing was expensive. Nevertheless, it makes for a nice sized dataset to start displaying trees. (For more details about the dataset and its origin, try entering ?esophagus into the command-line once you have loaded the phyloseq package)

The default tree without any additional parameters is plot with black points that indicate in how many different samples each OTU was found. In this case, the term “OTU” is used quite loosely (it is a loose term, after all) to mean entries in the taxononmic data you are plotting; and in the specific case of trees, it means the tips, even if you have already agglomerated the data such that each tip is equivalent to a rank of class or phylum.

```{r}
plot_tree(esophagus, title="Default tree.")
```
If for some reason you just want an unadorned tree, the "treeonly" method can be selected. This tends to plot much faster than the annotated tree, and is still a ggplot2 object that you might be able to add further layers to manually.
```{r}
plot_tree(esophagus, "treeonly", title="method = \"treeonly\"")
```
Now let’s shade tips according to the sample in which a particular OTU was observed.
```{r}
plot_tree(esophagus, color="samples")
```
We can also scale the size of tips according to abundance; usually related to number of sequencing reads, but depends on what you have done with the data prior to this step.
```{r}
plot_tree(esophagus, size="abundance")
```
Both graphical features included at once.
```{r}
plot_tree(esophagus, size = "abundance", color = "samples")
```
There is some overlap of the tip points. Let’s adjust the base spacing to spread them out a little bit.
```{r}
plot_tree(esophagus, size="abundance", color="samples", base.spacing=0.03)
```
Good, now what if we wanted to also display the specific numeric value of OTU abundances that occurred more than 3 times in a given sample? For that, plot_tree includes the min.abundance parameter, set to Inf by default to prevent any point labels from being written.
```{r}
plot_tree(esophagus, size="abundance", color="samples", base.spacing=0.03, min.abundance=3)
```

#### More exammples with the Global Patterns dataset 

Subset Global Patterns dataset to just the observed Archaea.
```{r}
gpa <- subset_taxa(GlobalPatterns, Kingdom=="Archaea")
```
The number of different Archaeal taxa from this dataset is small enough for a decent tree plot.
```{r}
ntaxa(gpa)
```
That is to say, it is reasonable to consider displaying the phylogenetic tree directly for gpa. Too many OTUs means a tree that is pointless to attempt to display in its entirety in one graphic of a standard size and font. So the whole GlobalPatterns dataset probably a bad idea.
```{r}
ntaxa(GlobalPatterns)
```
Some patterns are immediately discernable with minimal parameter choices:
```{r}
plot_tree(gpa, color="SampleType")
```
```{r}
plot_tree(gpa, color="Phylum")
```
```{r}
plot_tree(gpa, color="SampleType", shape="Phylum")
```
```{r}
plot_tree(gpa, color="Phylum", label.tips="Genus")
```
However, the text-label size scales with number of taxa, and with common graphics-divice sizes/resolutions, these ~200 taxa still make for a somewhat crowded graphic.

Let’s instead subset further to just the Crenarchaeota
```{r}
gpac <- subset_taxa(gpa, Phylum=="Crenarchaeota")
plot_tree(gpac, color="SampleType", shape="Genus")
```
```{r}
plot_tree(gpac, color="SampleType", label.tips="Genus")
```
Let’s add some abundance information. Notice that the default spacing gets a little crowded when we map taxa-abundance to point-size:
```{r}
plot_tree(gpac, color="SampleType", shape="Genus", size="abundance", plot.margin=0.4)
```
So let’s spread it out a little bit with the base.spacing parameter, and while we’re at it, let’s call off the node labels…
```{r}
plot_tree(gpac, nodelabf=nodeplotblank, color="SampleType", shape="Genus", size="abundance", base.spacing=0.04, plot.margin=0.4)
```

#### Chlamydiae-only tree

```{r}
GP.chl <- subset_taxa(GlobalPatterns, Phylum=="Chlamydiae")
plot_tree(GP.chl, color="SampleType", shape="Family", label.tips="Genus", size="abundance", plot.margin=0.6)
```

## Powerful, flexible phyloseq bar plots

The following are examples to help get you started using the plot_bar function on your own phyloseq data.

### Global Patterns dataset examples

Load the dataset, and trim to just the Chlamydiae phylum.
```{r}
library("phyloseq"); packageVersion("phyloseq")
```
```{r}
library("ggplot2"); packageVersion("ggplot2")
```
ggplot2 package theme set. See the ggplot2 online documentation for further help.
```{r}
theme_set(theme_bw())
```
Load dataset
```{r}
data("GlobalPatterns")
gp.ch = subset_taxa(GlobalPatterns, Phylum == "Chlamydiae")
```

### Some initial basic plots

The following is the default barplot when no parameters are given. The dataset is plotted with every sample mapped individually to the horizontal (x) axis, and abundance values mapped to the veritcal (y) axis. At each sample’s horizontal position, the abundance values for each OTU are stacked in order from greatest to least, separate by a thin horizontal line. As long as the parameters you choose to separate the data result in more than one OTU abundance value at the respective position in the plot, the values will be stacked in order as a means of displaying both the sum total value while still representing the individual OTU abundances.
```{r}
plot_bar(gp.ch)
```
Add fill color to represent the Genus to which each OTU belongs.
```{r}
plot_bar(gp.ch, fill="Genus")
```
Now keep the same fill color, and group the samples together by the SampleType variable; essentially, the environment from which the sample was taken and sequenced.
```{r}
plot_bar(gp.ch, x="SampleType", fill="Genus")
```
Note that abundance values for the same OTU from the same SampleType will be stacked as separate bar segments, and so the segment lines may not accurately portray the observed richness (because the same OTU might be shown more than once for the same horizontal axis grouping). However, all other aspects of the representation are quantitative, with the total stacked bar height at each horizontal position indicating the sum of all reads for that sample(s). There is not attempt by plot_bar to normalize or standardize your data, which is your job to do (using other tools in the phyloseq pacakge, for instance) before attempting to interpret/compare these values between samples.

### More Sophisticated Organization using Facets

In the following example we elected to further organize the data using “facets” – separate, adjacent sub-plots. In this case the facets allow us to according to the genus of each OTU. Within each genus facet, the data is further separated by sequencing technology, and the enterotype label for the sample from which each OTU originated is indicated by fill color.
```{r}
plot_bar(gp.ch, "Family", fill="Genus", facet_grid=~SampleType)
```

### Further customization using ggplot2 layers

Note that additional customizations of the plot are always possible using standard ggplot2 layers. For example, the following code chunk shows a plot with jittered points add using a second plot layer.
```{r}
library("ggplot2")
p = plot_bar(gp.ch, "Family", fill="Genus", facet_grid=~SampleType)
p + geom_point(aes(x=Family, y=Abundance), color="black", position="jitter", size=3)
```

### Enterotypes dataset examples

First, load package (if you haven’t already), then trim Enterotype data to most abundant 10 genera.
```{r}
library("phyloseq")
data("enterotype")
TopNOTUs <- names(sort(taxa_sums(enterotype), TRUE)[1:10])
ent10   <- prune_species(TopNOTUs, enterotype)
```
The parameters to plot_bar in the following code-chunk were chosen after various trials. We suggest that you also try different parameter settings while you’re exploring different features of the data. In addition to the variables names of sample_data, the plot_bar function recognizes the names of taxonomic ranks, if present. In this example we have also elected to organize data by “facets” (separate, adjacent sub-plots) according to the genus of each OTU. Within each genus facet, the data is further separated by sequencing technology, and the enterotype label for the sample from which each OTU originated is indicated by fill color. Abundance values from different samples and OTUs but having the same variables mapped to the horizontal (x) axis are sorted and stacked, with thin horizontal lines designating the boundaries. With this display it is very clear that the choice of sequencing technology had a large effect on which genera were detected, as well as the fraction of OTUs that were assigned to a Genus.
```{r}
plot_bar(ent10, "SeqTech", fill="Enterotype", facet_grid=~Genus)
```
You could nix the approach in which OTU abundance values from different samples, different enterotypes, are stacked together and simply shaded differently, and instead opt to separate both the enterotype designation of the samples and the genus designation of the OTUs into one grid. Only a slight modification to the previous function call is necessary in that case (with an added fill to make it even easier to read):
```{r}
plot_bar(ent10, "Genus", fill="Genus", facet_grid=SeqTech~Enterotype)
```

#### Add ggplot2 layer to remove the OTU separation lines

The following example uses more ggplot2-package commands directly for customization, so you need to load the package first (which we did earlier, but I will show it again here for modularity).
```{r}
library("ggplot2")
```
Now you can save the previous plot as a variable, let’s call it p, and then add additional ggplot2 layering instructions that will, in effect, remove the dividing lines that separate OTUs from one another in the previous plot.
```{r}
p = plot_bar(ent10, "Genus", fill="Genus", facet_grid=SeqTech~Enterotype)
p + geom_bar(aes(color=Genus, fill=Genus), stat="identity", position="stack")
```

Application written in R [@RCoreTeam] using the Shiny framework [@Chang2015] and the phyloseq [@McMurdie2013] package.

# References